# SWE Practical Works

## Practical 2: Text File Analyzer

### Objective
In this lab, you will create a Python program that analyzes a text file and calculates various statistics using control structures. This exercise will help you practice file handling, string manipulation, and using loops and conditionals in Python.

### Exercises
1. Modify the program to count the number of unique words in the text.
2. Add a function to find the longest word in the text.
3. Implement a feature to count the occurrences of a specific word (case-insensitive).
4. Create a function to calculate the percentage of words that are longer than the average word length.


## Practical 3: Implementing Recursive and Iterative Fibonnaci Sequence Generators

### Objective
In this lab, you will implement both recursive and iterative approaches to generate Fibonacci sequences in Python. This exercise will help you understand the differences between recursive and iterative problem-solving techniques, as well as analyze their performance characteristics.

### Exercises
1. Modify the iterative function to return a list of Fibonacci numbers up to n, instead of just the nth number.
2. Implement a function that finds the index of the first Fibonacci number that exceeds a given value.
3. Create a function that determines if a given number is a Fibonacci number.
4. Implement a function that calculates the ratio between consecutive Fibonacci numbers and observe how it approaches the golden ratio.

### Discussion Questions
1. What are the advantages and disadvantages of the recursive approach compared to the iterative approach?
2. How does memoization improve the performance of the recursive function? Are there any drawbacks?
3. In what scenarios might you prefer to use a generator function over other implementations?
4. How does the space complexity differ between these implementations?



## Practical 4: Implementing Linear and Binary Search Algorithms

### Objective
In this lab, you will implement both linear and binary search algorithms in Python. You'll learn about the differences between these search methods, their time complexities, and when to use each one. This exercise will help you practice algorithm implementation, list manipulation, and control structures in Python.

### Exercises
1. Modify the linear search function to return all indices where the target appears, not just the first one.
2. Implement a function that uses binary search to find the insertion point for a target value in a sorted list.
3. Create a function that counts the number of comparisons made in each search algorithm.
4. Implement a jump search algorithm and compare its performance with linear and binary search.


## Practical 5: Implementing Stacks and Queues

### Objective
In this lab, you will implement stack and queue data structures in Python and use them to solve practical problems. This exercise will help you understand these fundamental data structures and their applications.

### Exercises
1. Implement a function that uses a stack to evaluate postfix expressions.
2. Create a function that uses two stacks to implement a queue.
3. Use a queue to implement a basic task scheduler that processes tasks in the order they were added.
4. Implement a function that uses a stack to convert infix expressions to postfix.


## Practical 6: Singly Linked List Implementation

### Objective
In this lab, you will implement a singly linked list data structure in Python. You'll create basic operations and list manipulation functions, gaining a deeper understanding of linked data structures and their operations.

### Exercises
1. Implement a method to find the middle element of the linked list.
2. Create a method to detect if the linked list has a cycle.
3. Implement a method to remove duplicates from an unsorted linked list.
4. Add a method to merge two sorted linked lists into a single sorted linked list.


## Practical 7: Implementing a Binary Search Tree

### Objective
In this lab, you will implement a Binary Search Tree (BST) in Python, including methods for insertion, deletion, search, and various traversal operations. This exercise will help you understand tree data structures and practice recursive algorithms.

### Exercises
1. Implement a method to find the maximum value in the BST.
2. Add a method to count the total number of nodes in the BST.
3. Implement a level-order traversal (breadth-first search) for the BST.
4. Create a method to find the height of the BST.
5. Implement a method to check if the tree is a valid BST.


## Practical 8: Implementing Sorting Algorithms

### Objective
In this lab, you will implement three classic sorting algorithms: Bubble Sort, Merge Sort, and Quick Sort. This exercise will help you understand the mechanics of these algorithms and compare their performance.

### Exercises
1. Implement an in-place version of Quick Sort to improve its space efficiency.
2. Modify Bubble Sort to stop early if the list becomes sorted before all passes are complete.
3. Implement a hybrid sorting algorithm that uses Insertion Sort for small subarrays in Merge Sort or Quick Sort.
4. Create a visualization of how each sorting algorithm works using a library like Matplotlib.


## Practical 9: Graph Data Structure and Traversal Algorithms

### Objective
In this lab, you will implement a graph data structure and basic graph traversal algorithms in Python. This exercise will help you understand graph representations and practice implementing depth-first search (DFS) and breadth-first search (BFS) algorithms.

### Exercises
1. Implement a method to find the shortest path between two vertices using BFS.
2. Add a method to detect cycles in the graph.
3. Implement Dijkstra's algorithm to find the shortest path in a weighted graph.
4. Create a method to determine if the graph is bipartite.



